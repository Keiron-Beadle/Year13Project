using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System.Collections.Generic;
using System.IO;

namespace _3D_Object_Moving
{
    /// <summary>
    /// This is the main type for your game.
    /// </summary>
    public class Game1 : Game
    {
        public const int MAPSIZE = 20; //The size of the map in which I'm loading
        public const int NUMBEROFZOMBIES = 1;
        public const int NUMBEROFWEAPONS = 1;        
        const float PLAYERSPEED = 10.5f;

        GameState _currentGame; //Holds which state the program is currently in.
        GraphicsDeviceManager graphics;
        SpriteBatch spriteBatch;
        KeyboardState _prevState;
        #region GameState Gameplay Variables & Objects
        int shootCooldown = 0; //Used to control how fast the user can fire bullets
        int zombieToAddIndex = 0; //Holds which index of the zombie list I need to replace when a zombie dies
        bool carryingWeapon; //If player holds a weapon or not
        int weaponToCarry; //Which weapon in the world they are holding
        SpriteFont gameText, healthText; //Used to display main text on paused screen
        Player player; //The camera used for viewing 3 dimensions
        List<XAxisWalls> xAxisWalls; //X Axis Walls covering the perimeter of the map.
        List<ZAxisWalls> zAxisWalls; //Z Axis Walls covering the perimeter of the map.
        List<MazeWalls> mazeWalls; //Walls that are inside the maze.
        Grid grid; //Used for A* pathfinding, it's a new 'Grid' of nodes 
        Floor floor; //The floor of the world
        List<Node> listOfNodes = new List<Node>(); //List of nodes in the world used by A*
        Point[] closestNodes = new Point[NUMBEROFZOMBIES]; //Little bit pointless right now as each zombie doesn't have individual closest nodes to player
                                                           //however, I hope to change this.
        List<Zombie> zombie = new List<Zombie>(); // The Program-Controlled Entitiy that chases the player  
        List<Point> zombieStart = new List<Point>(); //Currently starts the Zombie at the corner of the map
        List<Point> zombieTarget = new List<Point>(); //Holds where the Zombie is trying to get to
        Vector3[] zombieNextPos = new Vector3[NUMBEROFZOMBIES]; //The position where the Zombie should next go to
        Vector3[] zombieCurrentPos = new Vector3[NUMBEROFZOMBIES]; //The position that the zombie is currently at
        List<Point> zombieFinishedPath = new List<Point>(); //The entire path generated by A* to move Zombie to player    
        List<Items> weapons = new List<Items>(); //List of weapons in the world
        Node goalFlag;
        List<Vector3> weaponSpawn = new List<Vector3>(); //Positions of where weapons spawn
        List<Bullet> bullets = new List<Bullet>(); //List of bullets that have been fired by player
        Model enemyModel, gunModel; //Models of the zombies + gun
        InteractableRectangle[] pausedButtons = new InteractableRectangle[2]; //The buttons in the 'pause' menu
        Texture2D pausedTex; //The texture for them
        #endregion
        #region GameState Menu Variables & Objects
        MouseState _currentMouseState; //Used for checking if the player has clicked in the menu
        SpriteFont menuText; //The SpriteFont used for displaying text
        Texture2D logo, rectangleTex; //The logo used on the main menu + plain red texture for rectangles
        InteractableRectangle[] menuButtons = new InteractableRectangle[3]; //All the different choice rectangles
        Rectangle mouseCollisionBox; //Used to detect if the cursor is inside a rectangle
        int mouseX, mouseY; //Current X and Y of the mouse on screen
        #endregion
        #region Information Variables & Objects
        Texture2D infoPanel; //The texture that has the information 
        InteractableRectangle backButton; //The button that goes back to the main menu
        #endregion
        #region GameState GameOver Variables & Objects
        InteractableRectangle gameOverButton;
        #endregion
        BasicEffect effect; //Effect used for 3D display
        RasterizerState RS; //The cubes + Walls need an edited RasterizerState to properly display.

        bool[] zombieChangeNode = new bool[NUMBEROFZOMBIES]; //Array of which zombies need a change to their target node
        bool[] zombieFirstSearch = new bool[NUMBEROFZOMBIES]; //Array of whether it's the zombie's first search or not
        bool[] validMove = new bool[NUMBEROFZOMBIES]; //Array of whether the zombie is making a valid movement.
        bool setUpWorld = false, pausedGame = false; // setUpWorld - Bool used to check if
                                                  //everything has been positioned before letting the game run. 
                                                  //zombieFirstSearch - whether it's the A*'s first time running.
                                                  //zombieChangeNode - if the zombie has reached it's target, it needs a new next node.
                                                  //validMove - The zombie would sometimes try to move to the node it's already on and break,
                                                  // this was used in order to prevent that.
                                                  // pausedGame - check if gameplay is paused.

        char[,] mapArray;  //A 2D array containing the data read from a .txt file

        enum GameState
        {
            Menu, //State for main menu
            Information, //State for Information page
            Gameplay, //State for being in-game
            GameOver, //State for after death
            GameWin, //State for after win
        }

        public Game1()
        {
            graphics = new GraphicsDeviceManager(this); //Sets which graphicsdevice to use
            Content.RootDirectory = "Content"; //Directory to read external data from e.g. Textures
            graphics.PreferredBackBufferHeight = 1080; //I chose 1920x1080 arbitrarily for the resolution
            graphics.PreferredBackBufferWidth = 1920;  //It's a popular 16:9 ratio that has a lot of pixels to work with.
        }

        protected override void Initialize()
        {
            player = new Player(this, new Vector3(15f, 1.3f, 15f), Vector3.Zero, PLAYERSPEED); // Instance of Camera created, has position + velocity.   // 15f 1.3f 15f
            Components.Add(player); //Adds the camera to the components of the game.
            pausedGame = false;
            xAxisWalls = new List<XAxisWalls>();  
            zAxisWalls = new List<ZAxisWalls>();
            mazeWalls = new List<MazeWalls>();
            mapArray = new char[MAPSIZE, MAPSIZE]; //Uses the constant to create a new 2D array for storing the map
            FillMapArray(mapArray); //Fills map from .txt file
            BuildMap(mapArray); //Builds 3D version of map using a key.

            floor = new Floor(GraphicsDevice, MAPSIZE  * 10, MAPSIZE * 10); //Creates a floor which fits within the map.
            grid = new Grid(listOfNodes, mapArray); //Passes the Nodes, walls and map to A*
            enemyModel = Content.Load<Model>("Zombie_low4");
            for (int i = 0; i < NUMBEROFWEAPONS; i++)
                weapons.Add(new Items(weaponSpawn[i], graphics.GraphicsDevice, grid, gunModel)); //Adds new weapon at spawnpoints
            
            effect = new BasicEffect(GraphicsDevice); 
            RS = new RasterizerState(); //New state for rendering walls + other vertice based objects
            RS.CullMode = CullMode.None; //Stops GPU from Culling sides of walls + cubes. 

            base.Initialize();
        }
         
        /// <summary>
        /// This entire subroutine was used in order to re-intialise the game if 'Play' is pressed from the main menu.
        /// I've transferred a few things that aren't essential from 'Initialise' to here for saving resources.
        /// </summary>
        void RepeatIntialise()
        {
            player.SetPlayerHealth(100);
            listOfNodes = new List<Node>();
            weapons = new List<Items>();
            player.Position = new Vector3(15f, 1.1f, 15f); //Resets position of player
            FillMapArray(mapArray); //Refills map in case user changes size/map after pressing 'play'.
            zombieStart = new List<Point>();
            zombie = new List<Zombie>();
            for (int i = 0; i < NUMBEROFZOMBIES; i++)
            {
                zombieStart.Add(grid.GetRandomStart(new Point((int)(player.Position.X - 5) / 10, (int)(player.Position.Z - 5) / 10), zombieStart));
                zombie.Add(new Zombie(new Vector3((zombieStart[i].X + 0.5f) * 10, 0f, (zombieStart[i].Y + 0.5f) * 10), graphics.GraphicsDevice, grid, enemyModel)); 
                zombieChangeNode[i] = true;
                zombieFirstSearch[i] = true;                                             //This resets all the zombies properties
                zombieCurrentPos[i] = (new Vector3(zombieStart[i].X, 0f, zombieStart[i].Y));
                zombie[i].Position = new Vector3((zombieStart[i].X + 0.5f) * 10, 0f, (zombieStart[i].Y + 0.5f) * 10);
            }
            for (int i = 0; i < NUMBEROFWEAPONS; i++)
            {
                weapons.Add(new Items(weaponSpawn[i], graphics.GraphicsDevice, grid, gunModel));
            }
            zombieTarget = new List<Point>();
            zombieNextPos = new Vector3[NUMBEROFZOMBIES];    
            zombieFinishedPath = new List<Point>();
           
            setUpWorld = false;
     
            for (int i = 0; i < validMove.Length; i++) { validMove[i] = true; }          

            pausedGame = false; 
        }

        /// <summary>
        /// Loads content I need
        /// </summary>
        protected override void LoadContent()
        {
            spriteBatch = new SpriteBatch(GraphicsDevice);
            pausedTex = Content.Load<Texture2D>("pausedTexture");
            gameText = Content.Load<SpriteFont>("GameFont");
            healthText = Content.Load<SpriteFont>("PlayerFont");
            menuText = Content.Load<SpriteFont>("MenuFont"); //Applies SpriteFont file to SpriteFont variable
            logo = Content.Load<Texture2D>("RemainingLogo"); //Applies relevent texture to logo variable.
            rectangleTex = Content.Load<Texture2D>("rectangleTex"); //Applies plain red texture to relevent object.
            infoPanel = Content.Load<Texture2D>("ControlsPage"); //Applies relevent page image to infoPanel.
            gunModel = Content.Load<Model>("gun");
            for (int i = 0; i < menuButtons.Length; i++)           
                menuButtons[i] = new InteractableRectangle(new Rectangle(Window.ClientBounds.Width / 2 - (logo.Width / 2), (rectangleTex.Height + 50) * i + 300, 400, 100), rectangleTex, 15);
            //Builds each rectangle on main menu with equal seperation from one-another
            for (int i = 0; i < pausedButtons.Length; i++)
                pausedButtons[i] = new InteractableRectangle(new Rectangle(225 + (i * 1000), Window.ClientBounds.Height - 200, 400, 100), rectangleTex, 15);
            backButton = new InteractableRectangle(new Rectangle(Window.ClientBounds.Width / 2 - (logo.Width / 2), (rectangleTex.Height + 50) + 740, 400, 100), rectangleTex, 15); //Builds back button on InfoPage.
            gameOverButton = new InteractableRectangle(new Rectangle(Window.ClientBounds.Width / 2 - (logo.Width / 2), (rectangleTex.Height + 50) + 740, 400, 100), rectangleTex, 15); //Builds game over button on GameOver.

        }

        /// <summary>
        /// Never need to unload so not used.
        /// </summary>
        protected override void UnloadContent()
        {
            //I'm never unloading any content so I don't use this. There's only 1 level,
            // thus I never saw the point in unloading things as nothing is unnecessary.
        }

        /// <summary>
        /// Fills an array to translate .txt data into game map info.
        /// </summary>
        void FillMapArray(char[,] inMapArray)
        {
            StreamReader sread = new StreamReader("map20.txt"); //Map file to use, '20' indicates a 20x20 grid is used in that .txt
            for (int i = 0; i < MAPSIZE; i++)
            {
                string line = sread.ReadLine();
                for (int j = 0; j < MAPSIZE; j++)
                {
                    if ((char)line[j] == ' ' || (char)line[j] == 'X' || (char)line[j] == 'O')
                    {
                        CreateNode(i, j); //If there's a blank space or weapon, a node must be placed.
                    }
                        inMapArray[i, j] = (char)line[j]; //Otherwise it's the character that is in the .txt file.
                    if ((char)line[j] == 'X')                   
                        weaponSpawn.Add(new Vector3(i * 10 + 5, 0.3f, j * 10 + 5));
                    if ((char)line[j] == 'O')
                        goalFlag = new Node(new Vector3(i * 10 + 5, 0.5f, j * 10 + 5), graphics.GraphicsDevice);
                    
                }
            }
            sread.Close();
        }

        /// <summary>
        /// Builds 3D map from map array.
        /// </summary>
        void BuildMap(char[,] inArray)
        {
            
            for (int i = 0; i < MAPSIZE; i++)
            {   for (int j = 0; j < MAPSIZE; j++)
                {
                    Vector3 position = new Vector3(i * 10, 0, j * 10); //This scales it up so that the walls aren't clustered.
                    switch (inArray[i, j]) //I might not need all these, I might decide to just use 'D' as they are much easier to create larger maps.
                    {
                        //This is the current Build key I'm using, it takes characters and applies the relevent wall to that position.
                        #region CurrentBuildKey
                        case 'Q':
                            xAxisWalls.Add(new XAxisWalls(position, graphics.GraphicsDevice));
                            break;
                        case 'W':
                            zAxisWalls.Add(new ZAxisWalls(position, graphics.GraphicsDevice));
                            break;
                        case 'U':
                            xAxisWalls.Add(new XAxisWalls(position + new Vector3(0, 0, 10), graphics.GraphicsDevice));
                            break;
                        case 'I':
                            zAxisWalls.Add(new ZAxisWalls(position + new Vector3(10, 0, 0), graphics.GraphicsDevice));
                            break;
                        case 'D':
                            mazeWalls.Add(new MazeWalls(position, graphics.GraphicsDevice));
                            break;
                        default:
                            break;
                            #endregion
                    }
                }
            }
        }

        /// <summary>
        /// Creates 3D nodes, called when 'FillMapArray' reads a 'X' OR ' ' 
        /// </summary>
        void CreateNode(int i, int j)
        {
            listOfNodes.Add(new Node(new Vector3(i * 10 + 5, 0.1f, j * 10 + 5), graphics.GraphicsDevice)); //Creates a node at the given position
        }

        #region UpdateVisitedNodes - DISABLED - Used for debugging
        /*
        void UpdateVisitedNodes(List<Node> inNodes)
        {
            foreach (Node n in inNodes)
            {
                if (!n.changed) //This checks wheter the node has already had the colour change.
                {
                    n.UpdateNode(); //I update the node (change its colour)
                    n.changed = true; //then change it's property to say it has had the colour change.
                }
            }
            if (inNodes.Count > 0)
                inNodes.RemoveAt(0); //I then remove that node from the list to save memory.
                                     //While it seems redundant to have this + the (!n.changed) validation,
                                     //if the zombie passes over the same node, it would update the node regardless of the
                                     //fact that it has already had a colour change. This saves processing power.
        }*/
        #endregion

        /// <summary>
        /// This subroutine is used for recreating dead zombies. It uses 'insert' istead of 'Add' to keep the order of the Lists.
        /// </summary>
        /// <param name="inZombies"></param>
        void GenerateNewZombie(List<Zombie> inZombies)
        {
            zombieStart.Insert(zombieToAddIndex, grid.GetRandomStart(new Point((int)(player.Position.X - 5) / 10, (int)(player.Position.Z - 5) / 10), zombieStart)); 
            zombie.Insert(zombieToAddIndex, new Zombie(new Vector3((zombieStart[zombieToAddIndex].X + 0.5f) * 10, 0f, (zombieStart[zombieToAddIndex].Y + 0.5f) * 10),
                graphics.GraphicsDevice, grid, enemyModel)); //Makes a new zombie (currently a cube)
            zombieChangeNode[zombieToAddIndex] = true;
            zombieFirstSearch[zombieToAddIndex] = true;
            zombieCurrentPos[zombieToAddIndex] = (new Vector3(zombieStart[zombieToAddIndex].X, 0f, zombieStart[zombieToAddIndex].Y));
            zombie[zombieToAddIndex].Position = new Vector3((zombieStart[zombieToAddIndex].X + 0.5f) * 10, 0f, (zombieStart[zombieToAddIndex].Y + 0.5f) * 10);
        }

        /// <summary>
        /// This method checks basically all of the collision in the game, the player with walls, gun with player, bullets with zombies,
        /// zombies with player etc. 
        /// </summary>
        void CheckCollision()
        {
            int indexOfBulletToRemove = 0; //Saves which bullet needs to be removed at the end of it's life.
            bool removeBullet = false;
            for (int i = 0; i < zAxisWalls.Count; i++)
            {
                if (player.cameraBox.Intersects(zAxisWalls[i].collisionBox[i / zAxisWalls.Count])) //Checks if player has collided with zWalls.
                {
                    if (player.Position.X >= zAxisWalls[i].Position.X || player.Position.X <= zAxisWalls[i].Position.X) //Moves player back if they have
                        player.cameraPosition.X = player.comparisonVector.X;
                    if (player.cameraPosition.Z <= zAxisWalls[i].Position.Z || player.cameraPosition.Z >= zAxisWalls[i].Position.Z) 
                        player.cameraPosition.Z = player.comparisonVector.Z;
                    for (int j = 0; j < bullets.Count; j++)
                    {
                        if (bullets[j].IntersectNode(zAxisWalls[i].collisionBox[i / zAxisWalls.Count]))
                        {
                            removeBullet = true;
                            indexOfBulletToRemove = j;
                        }

                    }
                    if (removeBullet) { bullets.RemoveAt(indexOfBulletToRemove); }

                }
            }
            for (int i = 0; i < xAxisWalls.Count; i++)
            {
                if (player.cameraBox.Intersects(xAxisWalls[i].collisionBox[i / xAxisWalls.Count])) //Checks if player has collided with XWalls.
                {
                    if (player.Position.X >= xAxisWalls[i].Position.X || player.Position.X <= xAxisWalls[i].Position.X) //Moves player back if they have.
                        player.cameraPosition.X = player.comparisonVector.X;
                    if (player.cameraPosition.Z <= xAxisWalls[i].Position.Z || player.cameraPosition.Z >= xAxisWalls[i].Position.Z)
                        player.cameraPosition.Z = player.comparisonVector.Z;             
                }
                removeBullet = false;
                for (int j = 0; j < bullets.Count; j++)
                {
                    if (bullets[j].IntersectNode(xAxisWalls[i].collisionBox[i / xAxisWalls.Count]))
                    {
                        removeBullet = true;
                        indexOfBulletToRemove = j;
                    }

                }
                if (removeBullet) { bullets.RemoveAt(indexOfBulletToRemove); }

            }
            for (int i = 0; i < mazeWalls.Count; i++)
            {
                if (player.cameraBox.Intersects(mazeWalls[i].collisionBox[i / mazeWalls.Count]))
                {
                    if (player.Position.X >= mazeWalls[i].Position.X || player.Position.X <= mazeWalls[i].Position.X)
                        player.cameraPosition.X = player.comparisonVector.X;
                    if (player.Position.Z <= mazeWalls[i].Position.Z || player.Position.Z >= mazeWalls[i].Position.Z)
                        player.cameraPosition.Z = player.comparisonVector.Z;
                }
                removeBullet = false;
                for (int j = 0; j < bullets.Count; j++)
                {
                    if (bullets[j].IntersectNode(mazeWalls[i].collisionBox[i / mazeWalls.Count]))
                    {
                        removeBullet = true;
                        indexOfBulletToRemove = j;
                    }

                }
                if (removeBullet) { bullets.RemoveAt(indexOfBulletToRemove); }

            }

            if (player.cameraBox.Intersects(goalFlag.collisionBox))
            {
                _currentGame = GameState.GameOver;
            }

            if (!carryingWeapon)
            {
                for (int i = 0; i < NUMBEROFWEAPONS; i++)
                {
                    if (player.cameraBox.Intersects(weapons[i].collisionBox)) //Checks if the user intersects a weapon collision box...
                    {
                        carryingWeapon = true; //... this means the player has picked up a weapon.
                        weaponToCarry = i;
                        break;
                    }
                }

            }

            for (int i = 0; i < NUMBEROFZOMBIES; i++)
            {
                if (zombie[i].collisionBox.Intersects(player.cameraBox))
                {
                    player.RemovePlayerHealth(1); //If zombie hits player - their health is reduced
                    if (player.GetPlayerHealth() <= 0)
                    {
                        _currentGame = GameState.GameOver;
                    }
                }

                for (int j = 0; j < bullets.Count; j++)
                {
                    if (bullets[j].collisionBox.Intersects(zombie[i].collisionBox)) //Checks if bullet hit zombie
                    {
                        zombie[i].SetZombieHealth(zombie[i].GetZombieHealth() - 100); //Decreases zombie's health
                        bullets.RemoveAt(j); //Removes bullet
                    }
                }

                if (zombie[i].GetZombieHealth() <= 0) //Checks if zombie is dead
                {
                    zombieToAddIndex = i; //Saves which index this zombie was at
                    zombie.RemoveAt(i); //Removes zombie
                    zombieStart.RemoveAt(i); //Removes the Start position associated with this zombie
                    GenerateNewZombie(zombie); //Generates a new zombie in place of old.
                }
            }
        }

        /// <summary>
        /// Used to move the AI controlled entities.
        /// </summary>
        void AIMovement()
        {
            Point closestNodeToPlayer = player.ClosestNode(listOfNodes);
            for (int k = 0; k < NUMBEROFZOMBIES; k++) { closestNodes[k] = closestNodeToPlayer; } //Finds closest node to player
            for (int j = 0; j < zombie.Count; j++)
            {
                if (zombieChangeNode[j]) //If the zombie needs to change the node
                {
                    if (!zombieFirstSearch[j]) //If the path has already been generated, the zombie will follow it.
                    {
                        zombieCurrentPos[j] = zombieNextPos[j]; 
  
                        float tempX = zombieCurrentPos[j].X;
                        float tempZ = zombieCurrentPos[j].Z;
                        zombieStart[j] = new Point((int)tempX, (int)tempZ);
                    }

                    if (validMove[j]) //Checks that the zombie isn't trying to move to nothing,
                    {
                        zombieFinishedPath = grid.FindPath(zombieStart[j], closestNodes[j], listOfNodes); //Finds shortest path to closest node to player
                        zombieNextPos[j] = new Vector3(zombieFinishedPath[0].X, 0, zombieFinishedPath[0].Y); //Sets the zombie's next position to the next element in the shortest path algorithm
                    }
                    zombieFirstSearch[j] = false;
                    zombieChangeNode[j] = false;
                }
            }
            for (int i = 0; i < NUMBEROFZOMBIES; i++)
            {
                if (zombieFinishedPath[0] == zombieStart[i]) //If we get to the end of the path, the zombie can no longer make valid moves
                    validMove[i] = false; 
                //However, if it is still a valid move,
                if (validMove[i])
                {
                    zombie[i].MoveZombie(zombie[i].GetMovement(zombieCurrentPos[i], zombieNextPos[i]), zombieFinishedPath, i); //I move zombie
                }
                Node tempNode = new Node(new Vector3((zombieNextPos[i].X + 0.5f) * 10, 1, (zombieNextPos[i].Z + 0.5f) * 10), graphics.GraphicsDevice);
                zombieChangeNode[i] = zombie[i].IntersectNode(grid.GetBoundingBox(tempNode));
                validMove[i] = true;
            }

        }

        /// <summary>
        /// Updates Bullets mid-flight.
        /// </summary>
        void UpdateBullets(List<Bullet> inBullets)
        {
            int indexOfBulletToRemove = 0; //Saves which bullet needs to be removed at the end of it's life.
            bool removeBullet = false; //Determines whether a bullet needs to be removed or not
            for (int i = 0; i < inBullets.Count; i++)
            {
                if (inBullets[i].GetLookAt() == Vector3.Zero) //If the bullet currently doesn't have a path,
                    inBullets[i].SetLookAt(player.GetLookAt()); //It gets the camera's look at.

                inBullets[i].Update(); //All bullets are then updated.
            } 
            if (removeBullet) { inBullets.RemoveAt(indexOfBulletToRemove); } 
        }

        /// <summary>
        /// What to do on the GameState's of 'Menu' and 'Information'
        /// </summary>
        void Menu()
        {
            IsMouseVisible = true;  //Make cursor visible
            player.cameraMouseEnabled = false; //Stop the camera from setting position of the mouse
            mouseX = Mouse.GetState().X;
            mouseY = Mouse.GetState().Y;
            mouseCollisionBox = new Rectangle(mouseX, mouseY, 5, 5); //Setup collision box for colliding with rectangles
        }

        /// <summary>
        /// Main Update method for the game
        /// </summary>
        protected override void Update(GameTime gameTime)
        {
            KeyboardState state = Keyboard.GetState();
            _currentMouseState = Mouse.GetState();
            if (_currentGame == GameState.Menu)
                Menu();
            else if (_currentGame == GameState.Information)
                Menu();
            else if (_currentGame == GameState.GameOver)
                Menu();
            else if (_currentGame == GameState.Gameplay)
            {
                IsMouseVisible = false;
                player.cameraMouseEnabled = true;
                if (setUpWorld) //If the world has been setup
                {
                    if (pausedGame == false) //If the game is not paused
                    {
                        player.UpdateCamera(gameTime); //We update camera.
                        if (carryingWeapon) //If we're carrying a weapon
                        { //I change the rotation of the model to align better. + Change position of model.
                            weapons[weaponToCarry].SetRotationMatrix(Matrix.CreateRotationX(player.GetCameraRotation().X), Matrix.CreateRotationY(player.GetCameraRotation().Y));
                            weapons[weaponToCarry].SetPosition(player.GetWeaponPosition() + player.GetLookAtOffSet());
                            if (_currentMouseState.LeftButton == ButtonState.Pressed && shootCooldown == 0) //If we're able to shoot,
                            {
                                bullets.Add(new Bullet(player.Position + new Vector3(0f, -0.3f, 0f), graphics.GraphicsDevice)); //we add a new bullet
                                shootCooldown = 100; //Reset cooldown of a shot
                            }
                            if (shootCooldown > 0) //So long as the cooldown is >0 we need to decrease it to 0.
                                shootCooldown--;
                        }
                        CheckCollision(); //Checks for collision
                        AIMovement(); //Moves the zombies
                        UpdateBullets(bullets);  //Updates bullets of a given Bullet List.

                    }
                }
                if (Keyboard.GetState().IsKeyDown(Keys.Escape) && _prevState != state)
                {
                    pausedGame = !pausedGame; //If we're pressing Esc - it pauses.
                }
                _prevState = state; //Saves the old keyboard state.
                setUpWorld = true; //Sets SetupWorld to true.
            }

            base.Update(gameTime);
        }

        /// <summary>
        /// Small method which was used twice in 'Draw' so I put it into a subroutine. 
        /// Draws the 'Text' info for a few 'Interactable' Boxes. 
        /// </summary>
        /// <param name="index"></param>
        void DrawButtonText(int index)
        {
            menuButtons[index].Draw(spriteBatch);
            if (index == 0) menuButtons[index].DrawText(spriteBatch, "Play", menuText);
            if (index == 1) menuButtons[index].DrawText(spriteBatch, "Information", menuText); ;
            if (index == 2) menuButtons[index].DrawText(spriteBatch, "Quit", menuText);
        }
        
        /// <summary>
        /// Main Draw method for the game
        /// </summary>
        protected override void Draw(GameTime gameTime)
        {
            if (_currentGame == GameState.Menu)
            {
                GraphicsDevice.Clear(Color.Black);
                spriteBatch.Begin();
                spriteBatch.Draw(logo, new Rectangle(Window.ClientBounds.Width / 2 - (logo.Width / 2) - 20, Window.ClientBounds.Height / 15, logo.Width, logo.Height), Color.White);
                for (int i = 0; i < menuButtons.Length; i++)
                {
                    bool[] notColliding = { true, true, true, true }; //Used to determine if mouse interacts with boxes.
                    if (menuButtons[i].GetRectangle().Contains(mouseCollisionBox)) //If mouse is over the given menu button.
                    {
                        if (_currentMouseState.LeftButton == ButtonState.Pressed) //If we press left click while inside a menu button
                        {
                            switch (i) //we switch depending on which button it was.
                            {
                                case 0:
                                    spriteBatch.End();
                                    _currentGame = GameState.Gameplay;
                                    Mouse.SetPosition(GraphicsDevice.Viewport.Width / 2, GraphicsDevice.Viewport.Height / 2);
                                    RepeatIntialise(); //Runs gameplay and resets player + zombies + map (weapons).
                                    spriteBatch.Begin(); //Used for when the Paused menu is called
                                    break;
                                case 1:
                                    _currentGame = GameState.Information;
                                    break;
                                case 2:
                                    Exit(); //Exit just quits the game.
                                    break;
                                default:
                                    break;
                            }
                        }
                        if (menuButtons[i].GetTimer() < 50)
                            menuButtons[i].SetTimer(1);
                        DrawButtonText(i);
                        notColliding[i] = false;
                    }
                    else
                    {
                        DrawButtonText(i);
                    }

                    if (notColliding[i])
                    {
                        if (menuButtons[i].GetTimer() > 15) { menuButtons[i].SetTimer(-2); } //Used for 'fading' effect.
                    } 
                }

                spriteBatch.End();
            }
            else if (_currentGame == GameState.Information)
            {
                spriteBatch.Begin();
                spriteBatch.Draw(infoPanel, new Rectangle(0, 0, 1920, 1080), Color.White); //Default 2D drawing + textures for information panel.
                bool notColliding = true;
                if (backButton.GetRectangle().Contains(mouseCollisionBox))
                {
                    if (_currentMouseState.LeftButton == ButtonState.Pressed)                  
                        _currentGame = GameState.Menu;                  
                    

                    if (backButton.GetTimer() < 50)
                        backButton.SetTimer(1);
                    
                    backButton.Draw(spriteBatch);
                    backButton.DrawText(spriteBatch, "Back", menuText);
                    notColliding = false;
                }
                backButton.Draw(spriteBatch);
                backButton.DrawText(spriteBatch, "Back", menuText);
                if (notColliding)
                {
                    if (backButton.GetTimer() > 15)
                    {
                        backButton.SetTimer(-2);

                    }
                }
                spriteBatch.End();
            }
            else if (_currentGame == GameState.Gameplay)
            {
                GraphicsDevice.Clear(Color.Black);
                GraphicsDevice.DepthStencilState = DepthStencilState.Default;
                GraphicsDevice.BlendState = BlendState.Opaque;
                GraphicsDevice.RasterizerState = RS;
                floor.Draw(player, effect); //Draws the floor of the world.

                foreach (ZAxisWalls z in zAxisWalls)
                    z.Render(player.View, player.Projection); //Goes through each Z wall and draws it

                foreach (XAxisWalls x in xAxisWalls)
                    x.Render(player.View, player.Projection); //Same for X walls.

                foreach (MazeWalls m in mazeWalls)
                    m.Render(player.View, player.Projection); //Same for maze walls.

                //foreach (Node c in listOfNodes)  
                //    c.Render(camera.View, camera.Projection); //Used for debugging - shows the nodes.

                for (int i = 0; i < bullets.Count; i++)
                    bullets[i].Render(player.View, player.Projection); //Renders bullets

                for (int i = 0; i < NUMBEROFWEAPONS; i++)                
                    weapons[i].Render(player.View, player.Projection, i); //Renders weapons

                for (int i = 0; i < NUMBEROFZOMBIES; i++)               
                    zombie[i].Render(player.View, player.Projection, i); //Renders zombies

                goalFlag.Render(player.View, player.Projection);

                spriteBatch.Begin();
                spriteBatch.DrawString(healthText, "Health: " + player.GetPlayerHealth(), new Vector2(50, GraphicsDevice.Viewport.Height - 55), Color.White);
                spriteBatch.End();

                if (pausedGame)
                {
                    Menu();
                    spriteBatch.Begin();
                    spriteBatch.Draw(pausedTex, new Rectangle(0, 0, 1920, 1080), Color.White * 0.4f);
                    spriteBatch.DrawString(gameText, "PAUSED", new Vector2(Window.ClientBounds.Width / 2 - 190, 100), Color.White);
                    for (int i = 0; i < pausedButtons.Length; i++)
                    {
                        bool[] notColliding = { true, true };
                        if (pausedButtons[i].GetRectangle().Contains(mouseCollisionBox))
                        {
                            if (_currentMouseState.LeftButton == ButtonState.Pressed) //More 2D drawings for paused menu.
                            {
                                switch (i)
                                {
                                    case 0:
                                        pausedGame = false;
                                        break;
                                    case 1:
                                        _currentGame = GameState.Menu;
                                        break;
                                    default:
                                        break;
                                }
                            }
                            if (pausedButtons[i].GetTimer() < 50)
                                pausedButtons[i].SetTimer(1);
                            pausedButtons[i].Draw(spriteBatch);
                            if (i == 0) pausedButtons[i].DrawText(spriteBatch, "Resume", menuText);
                            if (i == 1) pausedButtons[i].DrawText(spriteBatch, "Menu", menuText);
                            notColliding[i] = false;
                        }
                        else
                        {
                            pausedButtons[i].Draw(spriteBatch);
                            if (i == 0) pausedButtons[i].DrawText(spriteBatch, "Resume", menuText);
                            if (i == 1) pausedButtons[i].DrawText(spriteBatch, "Menu", menuText);
                        }

                        if (notColliding[i])
                        {
                            if (pausedButtons[i].GetTimer() > 15)
                                pausedButtons[i].SetTimer(-2);
                        }
                    }
                    spriteBatch.End();
                }


            }
            else if (_currentGame == GameState.GameOver)
            {
                spriteBatch.Begin();
                GraphicsDevice.Clear(Color.Black);
                spriteBatch.DrawString(gameText, "Game Over", new Vector2(GraphicsDevice.Viewport.Width / 2 - 200, 80), Color.Red);
                bool notColliding = true;
                if (gameOverButton.GetRectangle().Contains(mouseCollisionBox))
                {
                    if (_currentMouseState.LeftButton == ButtonState.Pressed)
                        _currentGame = GameState.Menu;
                    if (gameOverButton.GetTimer() < 50)
                        gameOverButton.SetTimer(1);
                    gameOverButton.Draw(spriteBatch);
                    gameOverButton.DrawText(spriteBatch, "Menu", menuText);
                    notColliding = false;
                }
                gameOverButton.Draw(spriteBatch);
                gameOverButton.DrawText(spriteBatch, "Menu", menuText);
                if (notColliding)
                    if (gameOverButton.GetTimer() > 15)
                        gameOverButton.SetTimer(-2);         
                spriteBatch.End();
            }
            base.Draw(gameTime);
        }
    }
}
